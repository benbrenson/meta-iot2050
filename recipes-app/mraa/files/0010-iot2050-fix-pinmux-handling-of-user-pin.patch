From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Benedikt Niedermayr <benedikt.niedermayr@siemens.com>
Date: Thu, 18 Apr 2024 13:00:21 +0200
Subject: [PATCH] iot2050: fix pinmux handling of user pin

This properly sets up the regmux info definition for the user pin
(pin 20) and skips the debugfs/mmap regmux for it.
This also improves debugging by adding the actual pin number
in the debug message.

Signed-off-by: Benedikt Niedermayr <benedikt.niedermayr@siemens.com>
---
 src/arm/siemens/iot2050.c | 30 ++++++++++++++++++------------
 1 file changed, 18 insertions(+), 12 deletions(-)

diff --git a/src/arm/siemens/iot2050.c b/src/arm/siemens/iot2050.c
index a5c5ebed7a2d..418cde3091b4 100644
--- a/src/arm/siemens/iot2050.c
+++ b/src/arm/siemens/iot2050.c
@@ -124,17 +124,17 @@ iot2050_get_regmux_by_pinmap(int pinmap)
 }
 
 static mraa_result_t
-iot2050_mux_debugfs(const char *base_dir, const char *group, const char *function, mraa_gpio_mode_t gpio_mode)
+iot2050_mux_debugfs(int phy_pin, const char *base_dir, const char *group, const char *function, mraa_gpio_mode_t gpio_mode)
 {
     FILE *fd = NULL;
     char p_pinmux[PATH_MAX];
     char mux[MRAA_PIN_NAME_SIZE];
     int ret;
 
-    syslog(LOG_DEBUG, "iot2050: debugfs: enter\n");
+    syslog(LOG_DEBUG, "iot2050: debugfs (pin: %d): enter\n", phy_pin);
 
     if (!base_dir || !group || !function) {
-        syslog(LOG_ERR, "iot2050: debugfs: Invalid parameter base_dir=%s, group=%s, function=%s!\n", base_dir, group, function);
+        syslog(LOG_INFO, "iot2050: debugfs (pin: %d): Invalid parameter base_dir=%s, group=%s, function=%s!\n", phy_pin, base_dir, group, function);
         return MRAA_ERROR_INVALID_PARAMETER;
     }
 
@@ -162,7 +162,7 @@ iot2050_mux_debugfs(const char *base_dir, const char *group, const char *functio
             break;
     }
 
-    syslog(LOG_DEBUG, "iot2050: debugfs: group: %s, function: %s\n", mux, mux);
+    syslog(LOG_DEBUG, "iot2050: debugfs (pin: %d): group: %s, function: %s\n", phy_pin, mux, mux);
 
     ret = fprintf(fd, "%s %s\n", mux, mux);
     if (ret < 0) {
@@ -176,7 +176,7 @@ iot2050_mux_debugfs(const char *base_dir, const char *group, const char *functio
 err_close:
     fclose(fd);
 err:
-    syslog(LOG_ERR, "iot2050: debugfs: Pinmux failed(%d)! group: %s, function: %s", ret, group, function);
+    syslog(LOG_ERR, "iot2050: debugfs (pin: %d): Pinmux failed(%d)! group: %s, function: %s", phy_pin, ret, group, function);
     return ret;
 }
 
@@ -226,7 +226,7 @@ iot2050_mux_init_reg(int phy_pin, int mode)
     int8_t mux_mode;
     mraa_result_t ret;
 
-    if((phy_pin < 0) || (phy_pin > MRAA_IOT2050_PINCOUNT))
+    if((phy_pin < 0) || (phy_pin > MRAA_IOT2050_PINCOUNT) || phy_pin == 20)
         return MRAA_SUCCESS;
     if((mode < 0) || (mode >= MAX_MUX_REGISTER_MODE)) {
         return MRAA_ERROR_FEATURE_NOT_SUPPORTED;
@@ -240,7 +240,7 @@ iot2050_mux_init_reg(int phy_pin, int mode)
         return MRAA_ERROR_FEATURE_NOT_SUPPORTED;
     }
 
-    ret = iot2050_mux_debugfs(info->debugfs_path[mode], info->pmx_group[mode], info->pmx_function[mode], 0);
+    ret = iot2050_mux_debugfs(phy_pin, info->debugfs_path[mode], info->pmx_group[mode], info->pmx_function[mode], 0);
     if (ret != MRAA_SUCCESS)
         return iot2050_mux_mmap(phy_pin, mode, 0);
     return ret;
@@ -324,7 +324,7 @@ iot2050_gpio_mode_replace(mraa_gpio_context dev, mraa_gpio_mode_t mode)
                 goto failed;
             }
             if(info) {
-                ret = iot2050_mux_debugfs(info->debugfs_path[0], info->pmx_group[0], info->pmx_function[0], mode);
+                ret = iot2050_mux_debugfs(dev->phy_pin, info->debugfs_path[0], info->pmx_group[0], info->pmx_function[0], mode);
                 if (ret != MRAA_SUCCESS)
                     ret = iot2050_mux_mmap(dev->phy_pin, 0, mode);
 
@@ -336,7 +336,7 @@ iot2050_gpio_mode_replace(mraa_gpio_context dev, mraa_gpio_mode_t mode)
                 goto failed;
             }
             if(info) {
-                ret = iot2050_mux_debugfs(info->debugfs_path[0], info->pmx_group[0], info->pmx_function[0], mode);
+                ret = iot2050_mux_debugfs(dev->phy_pin, info->debugfs_path[0], info->pmx_group[0], info->pmx_function[0], mode);
                 if (ret != MRAA_SUCCESS)
                     ret = iot2050_mux_mmap(dev->phy_pin, 0, mode);
             }
@@ -348,7 +348,7 @@ iot2050_gpio_mode_replace(mraa_gpio_context dev, mraa_gpio_mode_t mode)
                 goto failed;
             }
             if(info) {
-                ret = iot2050_mux_debugfs(info->debugfs_path[0], info->pmx_group[0], info->pmx_function[0], mode);
+                ret = iot2050_mux_debugfs(dev->phy_pin, info->debugfs_path[0], info->pmx_group[0], info->pmx_function[0], mode);
                 if (ret != MRAA_SUCCESS)
                     ret = iot2050_mux_mmap(dev->phy_pin, 0, mode);
             }
@@ -1834,7 +1834,10 @@ mraa_siemens_iot2050()
                             -1,
                             -1,
                             wkup_gpio0_base+25,
-                            {}
+                            {0},
+                            {0},
+                            {0},
+                            {0}
                         });
     iot2050_pin_add_gpio(b, pin_index, wkup_gpio0_chip, 25, -1, -1, NULL, 0);
     pin_index++;
@@ -1915,7 +1918,10 @@ mraa_siemens_iot2050_sm()
                             .group = -1,
                             .index = -1,
                             .pinmap = wkup_gpio0_base+25,
-                            .mode = {}
+                            .mode = {0},
+                            .debugfs_path = {0},
+                            .pmx_function = {0},
+                            .pmx_group = {0},
                         });
     iot2050_pin_add_gpio(b, pin_index, wkup_gpio0_chip, 25, -1, -1, NULL, 0);
 
